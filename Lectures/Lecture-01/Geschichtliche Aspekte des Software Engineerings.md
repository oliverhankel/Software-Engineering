# Eine kurze Geschichte des Software Engineerings

## Intro: Warum ein kurzer Blick in die Geschichte des Software Engineering lohnt

> Sei Dir sicher, Dein aktuelles Problem hat schon jemand vor Dir gehabt und gelöst

Manchmal ist es hiflreich zu verstehen, was unsere Vorgänger angetrieben hat, diese Vielzahl an Programmiersprachen, Lösungsmustern, Architekturen, Frameworks und Methoden zu entwickeln, denen wir heute gegenüberstehen.

Zum Beispiel ist die funktionale Programmierung *functional programming* keine Erfindung der Javascript (ECMAScript) Macher sondern ist schon seit 1958 in Form von LISP spezifiziert worden.

Ein Blick in die Geschichte hilft schlichtweg dabei, jedem (Software-)Hype gelassen entgegen zu sehen. Es ermöglicht Dir, eine einfache Einsortierung. Manchmal kannst Du Dich auch in die Namen der innovativen Vordenker des Software Engineerings erinnern, und nach diesen im Internet suchen, um in deren Originaltexten Inspiration für die Lösung Deiner akuten Probleme zu bekommen. 

Im Folgenden sind eine kurzer historischen des Software Engineerings zu finden, der die interessanten Meilensteine der Entwicklung enthält. Es gibt im Internet vielerlei Quellen, die ich hier nur zusammengefasst habe.

## 1960er : Der Begriff Software Engineering etabliert sich

Von wem oder bei welcher Gelegenheit der Begriff Sofware Engineering entstanden ist, lässt sich nicht klar nachvollziehen. 
Manchen schreiben [Margaret Hamilton](https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer)) zu, dass sie der Auffassung war, dass die Software Entwickler auch *Engineers* seien. 

Sehr gut belegt ist, aber dass es 1968 die erste NATO Software Engineering Conference abgehalten worden ist.
http://homepages.cs.ncl.ac.uk/brian.randell/NATO/NATOReports/

Ein Auszug aus dem Report dieser Konferenz ist für uns allerdings hochineressant, weil in diesem alle Aspekte genannt sind, mit denen wir uns beschäftigen müssen:

> The discussions cover all aspects of software including
>  - relation of software to the hardware of computers 
>  - design of software
>  - production, or implementation of software
>  - distribution of software
>  - service on software. 
>  By including many direct quotations and exchanges of opinion, the report reflects the lively controversies of the original discussion. Although much of the discussions were of a detailed technical nature, the report also contains sections reporting on discussions which will be of interest to a much wider audience. This holds for subjects like
>  - the problems of achieving sufficient reliability in the data systems which are becoming increasingly integrated into the central activities of modern society
>  - the difficulties of meeting schedules and specifications on large software projects
>  - the education of software (or data systems) engineers
>  - the highly controversial question of whether software should be priced separately from hardware [^1]

Die hier aufgeführten Punkte mündeten in den Entwicklungen, die in den folgenen Dekanden stattfand.

In den folgenden 60 Jahren haben sich die Methoden, Prozesse und Tools entwickelt, die wir in diesen Lektionen durchgehen wollen.


## 1970er: Unix & erste "Hochsprachen" & der erste PC 

Ab 1970 gibt es die Sprache Pascal, bei der es Datenstrukturen/typen gibt und strukturierte Programmierung unterstützt. Entwickelt wurde sie von Nicklaus Wirth.

1972 war ein großartiges Jahr: Die Programmiersprache C und Unix traten ins Licht der Welt

1975 konnte man für erschwingliche $400 den  ersten PC "[Altair 8800](https://en.wikipedia.org/wiki/Altair_8800)" kaufen. 

Ende der 1970er konnte man bereits Computer Engineering an der Seattle University studieren.


## 1980er: OO & CASE & Internet

Lass uns die 80er kurz zusammenfassen: Die Idee der objekt-orientierten Sprachen wurde geboren (Ada). 

Und was noch viel spannender ist: CASE Tools wurden zum erste Mal eingesetzt: [Computer-Aided-Software Engineering](https://www.umsl.edu/~sauterv/analysis/F08papers/View.html)


Das Arpanet, der Vorgänger des Internets, bekam TCP/IP.[^2]


## 1990er: WWW & Noch mehr "Hochsprachen" & XP

Die 90er sind geprägt von dem Erscheinen der ersten Internettechnologien. 
Allen voran wird zum ersten Mal das Protokoll HTTP - entwickelt von Tim Berners-Lee - genutzt. 
Java wird als Sprache entwickelt und dann kommt auch noch Javascript dazu, die als Skriptsprache für die Dynamisierung von Webseiten genutzt wird. 

Ende der 90er entwickelt Kent Beck die ersten Ideen, wie man mit schnell ändernden Kundernanforderungen umgehen kann. Er nennt es *extreme Programming*.


## 2000er: Agile (Leichtgewichtige Software-Entwicklung)

In 2001 wurde das [Agile Manifest](https://agilemanifesto.org/) formuliert.

Viel interessanter für die Diszpling *Software Engineering* war das Erscheinen des Buchs **Software Engineering Body of Knowledge (SWEBOK)** im Jahr 2004, damit hatte sich Software Engineering als Studienrichtung etabliert. 
Später wurden die Inhalte des SWEBOK in das ISO Format [197559:2015](https://www.iso.org/obp/ui/#iso:std:iso-iec:tr:19759:ed-2:v2:en) aufgenommen.


## 2010er: Cloud & die Rückkehr von AI

Was soll zu den letzten zehn Jahren sagen? Die Virtualisierung ist vorangeschritten und endet damit, dass mittlerweile auch die Infrastruktur virtualisiert worden ist. Dies nennen wir Cloud.

Anfang der 2000er war man der Meinung, dass die Verwendung der neuronalen Netze zur Schaffung von künstlicher Intelligenz aufgrund von fehlender Rechenleistung und mangelnder Daten nichts taugt. Doch dank der großen Tech-Konzerne, die einen Haufen Daten sammeln, die riesige Rechenzentren geschaffen und mithilfe der Chiphersteller eine unglaubliche Rechenleistung zur Verfügung stellt haben, wurde gerade im Bereich Objekterkennung, Computer Vision und Sprachverarbeitung unglaubliches geleistet. AI war also doch nicht tot.

Das nächste große Ding wird aber Quantencomputing sein. 

Wir können festhalten, die Kernprobleme haben sich in den letzten 60 Jahren nicht verändert (Hardware-Entwicklung vs. Software-Entwicklung, Qualitätssicherung, Handhabung von komplexer Software). 
Es hat sich nicht gezeigt, dass keine generelle Lösung gibt, die anwendbar, um alle Software Engineering Aufgaben auf einmal zu lösen. Vielmehr ist Software Engineering eine Ingenieursdisziplin, wie jede andere auch.






[^1]: [[@http___zotero.org_users_local_ZrCg5Awg_items_DZSUXBRS]]
[^2]: [[@http___zotero.org_users_local_ZrCg5Awg_items_BNHP8329]]